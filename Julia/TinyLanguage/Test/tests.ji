# test/runtests.jl
using Test

# tiny_lang.jl laden (relativ zum Test-Ordner)
include(joinpath(@__DIR__, "..", "tiny_lang.jl"))

# --- kleine Helpers ----------------------------------------------------------

"Tokenize alles, inkl. EOF"
function lex_all(s::AbstractString)
    lx = Lexer(String(s))
    toks = Token[]
    while true
        t = next_token(lx)
        push!(toks, t)
        t.kind == :EOF && break
    end
    return toks
end

"Programm kompilieren, in Modul laden und Ausgabe in Buffer schreiben (Julia 1.12 stabil)"
function run_tiny(src::AbstractString)
    code = compile_to_julia(String(src))

    io = IOBuffer()               # Buffer im äußeren World
    m = Module(:TL_Run)

    # Das Modul soll in "io" schreiben:
    Core.eval(m, :(const __cap_io = $io))
    Core.eval(m, :(println(args...) = Base.println(__cap_io, args...)))

    # Generierten Code im Modul ausführen (nutzt das lokale println)
    Base.include_string(m, code, "generated_test.jl")

    # Ausgabe auslesen (ohne __cap_io wieder anzufassen)
    return String(take!(io))
end


# --- Tests -------------------------------------------------------------------

@testset "Lexer basics" begin
    toks = lex_all("let x = 12;")
    @test [t.kind for t in toks] == [:KW, :NAME, :SYMBOL, :NUMBER, :SYMBOL, :EOF]
    @test toks[1].text == "let"
    @test toks[2].text == "x"
    @test toks[4].text == "12"
end

@testset "Arithmetic & print" begin
    out = run_tiny("""
        let a = 7 + 5 * 2;
        print(a);
    """)
    @test strip(out) == "17"
end

@testset "Comparisons" begin
    out = run_tiny("""
        print(3 >= 3);
        print(2 < 3);
    """)
    @test strip(out) == "true\ntrue"
end

@testset "Function + return + call-stmt" begin
    out = run_tiny("""
        fn add(a,b) { return a + b; }
        let x = 40;
        let y = 2;
        print(add(x,y));
    """)
    @test strip(out) == "42"
end

@testset "Heap new/delete + get/set" begin
    out = run_tiny("""
        let p = new(2);
        heap_set(p, 0, 41);
        heap_set(p, 1, 1);
        print( heap_get(p, 0) + heap_get(p, 1) );
        delete(p);
    """)
    @test strip(out) == "42"
end

@testset "operator overloading (Box + Box)" begin
    out = run_tiny("""
        operator + (a: Box, b: Box) -> Box {
          return box(unbox(a) + unbox(b));
        }
        let x = box(20);
        let y = box(22);
        let z = x + y;
        print(unbox(z));
    """)
    @test strip(out) == "42"
end

@testset "operator == (Box == Box)" begin
    out = run_tiny("""
        operator == (x: Box, y: Box) -> Bool {
          return unbox(x) == unbox(y);
        }
        let a = box(5);
        let b = box(5);
        let c = box(7);
        print(a == b);
        print(a == c);
    """)
    @test strip(out) == "true\nfalse"
end

@testset "Syntax error reporting" begin
    @test_throws ErrorException compile_to_julia("let = 1;")
    @test_throws ErrorException compile_to_julia("operator + (a: Box, b: Box) Box { }") # fehlt '->'
end
